# -*- coding: utf-8 -*-
"""ckd-new.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NML5HRJ3ySlskcOjvMHvMY5hh1IrrWg5
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import ipywidgets as widgets
from IPython.display import display, clear_output
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix

df = pd.read_csv('/content/CKD_Cleaned.csv')

if 'id' in df.columns:
    df.drop(columns=['id'], inplace=True)

df.columns = df.columns.str.strip().str.lower().str.replace(" ", "_").str.replace("'", "")
df.replace(['?', '', 'NA', 'na', 'NaN', 'nan', ' '], np.nan, inplace=True)

if 'class' in df.columns:
    df.rename(columns={'class': 'classification'}, inplace=True)

df['classification'] = df['classification'].astype(str).str.strip().str.lower()

df.dropna(axis=1, thresh=int(0.5 * len(df)), inplace=True)
df.dropna(axis=0, thresh=int(0.5 * len(df.columns)), inplace=True)

for col in df.columns:
    if df[col].dtype == 'object':
        df[col].fillna(df[col].mode()[0], inplace=True)
    else:
        df[col] = pd.to_numeric(df[col], errors='coerce')
        df[col].fillna(df[col].median(), inplace=True)

df_encoded = df.copy()
encoders = {}

for col in df_encoded.columns:
    if df_encoded[col].dtype == 'object':
        le = LabelEncoder()
        df_encoded[col] = le.fit_transform(df_encoded[col])
        encoders[col] = le

X = df_encoded.drop('classification', axis=1)
y = df_encoded['classification']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

model = RandomForestClassifier(random_state=42, class_weight='balanced')
model.fit(X_train, y_train)

y_pred = model.predict(X_test)

print(" Accuracy:", accuracy_score(y_test, y_pred))
print(" Confusion Matrix:\n", confusion_matrix(y_test, y_pred))
print(" Classification Report:\n", classification_report(y_test, y_pred))

input_fields = X.columns.tolist()
widgets_list = []
user_widgets = {}

for field in input_fields:
    if field in encoders and field != 'classification':
        opts = list(encoders[field].classes_)
        user_widgets[field] = widgets.Dropdown(
            options=opts, description=field.upper()+":", style={'description_width': 'initial'}
        )
    else:
        user_widgets[field] = widgets.FloatText(
            value=float(df[field].median()), description=field.upper()+":", style={'description_width': 'initial'}
        )
    widgets_list.append(user_widgets[field])

btn = widgets.Button(description=" Predict CKD", button_style='success')
output = widgets.Output()
widgets_list.append(btn)
widgets_list.append(output)

def on_click(b):
    with output:
        clear_output()
        input_data = {}
        for field in input_fields:
            val = user_widgets[field].value
            if field in encoders:
                try:
                    val = encoders[field].transform([val])[0]
                except:
                    val = encoders[field].transform([encoders[field].classes_[0]])[0]
            input_data[field] = val

        df_input = pd.DataFrame([input_data])
        prediction = model.predict(df_input)[0]
        class_label = encoders['classification'].inverse_transform([prediction])[0]
        confidence = model.predict_proba(df_input)[0][prediction] * 100

        print(" Prediction Result:")
        print(f" Class: {class_label.upper()}")
        print(f" Confidence: {confidence:.2f}%")

btn.on_click(on_click)

display(widgets.VBox(widgets_list))

plt.figure(figsize=(16, 12))
corr = df_encoded.corr()
mask = np.triu(np.ones_like(corr, dtype=bool))

sns.set(style="white")
ax = sns.heatmap(
    corr,
    mask=mask,
    cmap='coolwarm',
    annot=True,
    fmt=".2f",
    linewidths=0.6,
    square=True,
    cbar_kws={"shrink": 0.8},
    annot_kws={"size": 9}
)

plt.xticks(rotation=45, ha='right', fontsize=10)
plt.yticks(rotation=0, fontsize=10)
plt.title("Feature Correlation Heatmap", fontsize=16, fontweight='bold', pad=20)
plt.tight_layout()
plt.show()

plt.figure(figsize=(6, 4))
sns.countplot(x='classification', data=df, palette='pastel')
plt.title("CKD vs Non-CKD Distribution", fontsize=14)
plt.grid(axis='y')
plt.show()

top_corr = df_encoded.corr()['classification'].abs().sort_values(ascending=False)[1:6]

plt.figure(figsize=(6, 4))
top_corr.plot(kind='barh', color='tomato')
plt.xlabel("Correlation with CKD")
plt.title("Top 5 Correlated Features", fontsize=14)
plt.grid(True)
plt.show()

# Boxplot: Blood Pressure vs CKD
plt.figure(figsize=(7, 4))
sns.boxplot(x='classification', y='bp', hue='classification', data=df, palette="Set1", dodge=False, legend=False)
plt.title('Blood Pressure by CKD Classification')
plt.xlabel('Classification (0 = Not CKD, 1 = CKD)')
plt.ylabel('Blood Pressure (mm Hg)')
plt.grid(True)
plt.tight_layout()
plt.show()

# Step 9: Print Model Comparison Table (Cleaned)
print("Model Comparison Table:")
print(results_df.round(3))  # Round to 3 decimal places for better readability

# Minimal example data to visualize (replace with your actual model results if available)
results_df = pd.DataFrame({
    "Model": ["Logistic Regression", "SVM", "Decision Tree", "Random Forest"],
    "Accuracy": [0.91, 0.88, 0.85, 0.93]
})

# Plot
plt.figure(figsize=(10, 6))
ax = sns.barplot(x='Model', y='Accuracy', data=results_df, palette='Set2')

# Add labels on top
for p in ax.patches:
    acc = p.get_height()
    ax.annotate(f'{acc:.2f}',
                (p.get_x() + p.get_width() / 2., acc + 0.01),
                ha='center', va='bottom', fontsize=10)

plt.title('Model Accuracy Comparison', fontsize=14)
plt.ylabel('Accuracy')
plt.xlabel('Model')
plt.ylim(0, 1.1)
plt.grid(axis='y')
plt.tight_layout()
plt.show()

